#!/usr/bin/env bash

echo "ğŸ” Running pre-commit checks..."

# Try to use NVM's Node.js if available
if [ -s "$HOME/.nvm/nvm.sh" ]; then
  # Load NVM
  export NVM_DIR="$HOME/.nvm"
  \. "$NVM_DIR/nvm.sh" # This loads nvm
  
  # Use Node.js 20+
  nvm use 20 >/dev/null 2>&1
  
  echo "âœ… Using Node.js $(node -v) from NVM"
fi

# Require Node.js 20+ as specified in package.json
node_version=$(node -v | cut -d. -f1 | sed 's/v//')
if [ "$node_version" -lt 20 ]; then
  echo "âŒ Error: Node.js version $(node -v) is incompatible. This project requires Node.js 20.19.0+."
  echo "âŒ Commit aborted. Please use Node.js 20+ for development."
  exit 1
fi

# Check if there are any staged files
staged_files=$(git diff --cached --name-only --diff-filter=ACMR)
if [ -z "$staged_files" ]; then
  echo "â„¹ï¸ No files staged for commit, skipping checks."
  exit 0
fi

# Validate commit message FIRST (before expensive operations) if available
# Note: When using `git commit -m`, git creates .git/COMMIT_EDITMSG AFTER pre-commit runs
# However, if the file exists from a previous failed commit, we validate it first
# This optimizes the common case where user fixes message and retries
commit_msg_file=".git/COMMIT_EDITMSG"
msg_validated=false

if [ -f "$commit_msg_file" ]; then
  # Check if file has actual content (not just whitespace)
  msg_content=$(head -1 "$commit_msg_file" 2>/dev/null | xargs)
  if [ -n "$msg_content" ]; then
    echo "ğŸ” Validating commit message format (early check before expensive operations)..."
    # Skip validation only in actual CI environments
    if [ -z "$GITHUB_ACTIONS" ] && [ -z "$CIRCLECI" ] && [ -z "$GITLAB_CI" ] && [ -z "$JENKINS_URL" ] && [ -z "$TRAVIS" ] && [ -z "$BUILDKITE" ]; then
      if ! npx --no -- commitlint --edit "$commit_msg_file" >/dev/null 2>&1; then
        echo ""
        echo "âŒ Commit message format is invalid!"
        echo ""
        echo "ğŸ“‹ Allowed scopes: role-manager, components, hooks, deps, config, ci, docs, spec, tests, release, ui, utils, types"
        echo "ğŸ“‹ Allowed types: build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test, wip"
        echo ""
        echo "Example: feat(role-manager): add new feature"
        echo ""
        echo "ğŸ’¡ Tip: Commit message validation failed. Fix the message and try again."
        echo ""
        exit 1
      fi
      echo "âœ… Commit message format is valid"
      msg_validated=true
    fi
  fi
fi

# If message wasn't validated here (file doesn't exist yet with -m flag),
# prepare-commit-msg hook will validate it and fail fast if invalid
# This means formatting/linting might run once, but subsequent attempts will be validated early

# Check for local tarball dependencies in package.json
# We want to prevent committing local file paths that won't work in CI
# Only check if package.json is among the staged files
if echo "$staged_files" | grep -q "apps/role-manager/package.json"; then
  if grep -q "file:.*contracts-ui-builder" apps/role-manager/package.json; then
    echo ""
    echo "âŒ Error: Local tarball dependencies detected in package.json!"
    echo "   These paths (file:...) will fail in CI/production."
    echo ""
    echo "   ğŸ‘‰ Run 'pnpm dev:registry' to switch to registry versions."
    echo ""
    exit 1
  fi
fi

# Run formatting and linting on staged files (expensive operations - only if message is valid)
echo "ğŸ¨ Running formatting and linting..."
pnpm fix-all
